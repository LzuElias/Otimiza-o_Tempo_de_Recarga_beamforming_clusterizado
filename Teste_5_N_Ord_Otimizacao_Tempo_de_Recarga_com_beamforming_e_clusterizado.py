# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nJm42HNDHbuBu609qtPcqUN52VtzHwSD
"""

# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JZXb2JwwPlFXiKxMmr7SwrFLdFbwDyjH
"""

#%% Definições

# - Beta_k = ganho médio de potência no canal entre o PB e o k-ésimo dispositivo;
# - s_k = sinal transmitido (variável aleatória gaussiana de média zero e variancia unitária);
# - Psi_k = vetor beamforming analógico (Pertence aos complexos com tamanho 1xN);
# - ||Psi_k||² = Potencia de transmissão (Pt);
# - h_k = Vetor de canal (pertence aos complexos com tamanho 1xN);
# - kappa_PB_D = fator de rice;

# OBS: k = K. j = 1 e vai até j = k-1


#%% -------------------------   IMPORTAÇÕES e PARÂMETROS   ----------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.cluster import DBSCAN

import random

seed = np.random.seed(9)

K = 10                                  # N° dispositivos
N = 4                                   # N° de antenas
R = 50                                  # Raio [m]
L = 1                                   # N° de RIS
f = 915 *(10**6)                        # Freq. da portadora
kappa_PB_D = 1.5                        # Fator Rice PB-Disp
kappa_PB_RIS = 1.5                      # Fator Rice PB-Disp
kappa_RIS_D = 1.5                       # Fator Rice PB-Disp
mu = 10.73 * 10**(-3)                   # Max pot no IoT
a = 0.2308                              # constante circuito a
b = 5.365                               # constante circuito b
Pt = 3                                  # Max pot. de transmissão
E_min = 1* (10**-6)                     # Min Energia no IoT [J]
alpha = 1.0                             # Coef. perda de percurso sem visada direta
alpha2 = 1.0                              # Coef. perda de percurso com visada direta
c = 3*(10**(8))                         # Vel. da luz
Omega = 1/(1+(np.exp(a*b)))             # Constante resposta 0_in-0_out
Pot_k = 0
# Parâmetros Ris
M = 40                                 # Linha e Coluna das células da Ris


#  Para acréscimo da RIS
RIS = np.zeros((L,L))
RIS = [[1]]
theta = np.zeros((M, M)).astype(complex)                    # theta é a fase da matriz da RIS
Beta2 = np.zeros((L))                                       # Beta para Power_Beacon-RIS e RIS-Disp


#%% ----------------------------   CONSTRUÇÃO DA RIS   ------------------------------------------------------------------

theta_aux = np.zeros(M).astype(complex)
# Montagem da RIS
for linha in range (0,M):
    ris_phase = np.random.random()
    theta_aux[linha] = np.exp(-1j*(ris_phase*2*np.pi))
theta = np.diag(theta_aux)


#%% --------------------   GERAÇÃO DA LOCALIZAÇÃO DOS DISPOSITIVOS   ------------------------------------------------------

seed = np.random.seed(7)

# Posições do PB e RIS
PB_position = np.array([0, 0])
RIS_position = np.array([R * 0.8, R * 0.8])

N_set_disp = 10
N_realizacao = 1
tempo_carregamento_total = np.zeros((N_realizacao,N_set_disp))
tempo = np.zeros(8)
x_min, x_max = min(PB_position[0], RIS_position[0]), max(PB_position[0], RIS_position[0])
y_min, y_max = min(PB_position[1], RIS_position[1]), max(PB_position[1], RIS_position[1])

# --- for de 1 até 100

Set_x_disp = np.random.uniform(x_min, x_max, [N_set_disp,8*K])
Set_y_disp = np.random.uniform(y_min, y_max, [N_set_disp,8*K])

cont = 0

eixo_x_N = np.array(8) 


for N in range(4,20,2):
  print(N)
  for n_disp in range(N_set_disp):

    # Gerando coordenadas x e y uniformemente dentro do retângulo
    x_disp = Set_x_disp[n_disp, 0:K]
    y_disp = Set_y_disp[n_disp, 0:K]

    # Armazenando as coordenadas dos dispositivos
    loc_dispositivos = np.vstack((x_disp, y_disp)).T

    for real in range(N_realizacao):

      #  ------------------   ELBOW METHOD PARA O N° DE CLUSTERS   -----------------------------------

      from sklearn.metrics import silhouette_samples, silhouette_score

      # Cria a Curva de Cotovelo para encontrar o Numero Ideal de Clusters
      wcss = []
      melhor_score = -1  # Inicializa com um valor baixo
      melhor_n_clusters = 2  # Inicializa com o mínimo de clusters

      for i in range(1, K):
          kmeans = KMeans(n_clusters = i, max_iter = 300, n_init = 10, random_state = 0)
          kmeans.fit(loc_dispositivos)
          wcss.append(kmeans.inertia_)


      for i in range(2, K):
          clusterer = KMeans(n_clusters=i)
          preds = clusterer.fit_predict(loc_dispositivos)
          score = silhouette_score(loc_dispositivos, preds)

          if score > melhor_score:
              melhor_score = score
              melhor_n_clusters = i

      # ------------------------------   CLUSTERIZAÇÃO   ----------------------------------------------------------------

      n_cluster = melhor_n_clusters
      loc_dispositivos2 = np.vstack((x_disp, y_disp)).T
      k_means = KMeans(n_clusters = n_cluster, random_state=seed).fit(loc_dispositivos2)
      cluster_labels = k_means.labels_

      # --------------------   Separação dos dispositivos por cluster   --------------------------------------------------------

      labels = cluster_labels

      # Separando dispositivos em clusters com base nos rótulos
      unique_labels = set(labels)
      clusters = {label: loc_dispositivos2[labels == label] for label in unique_labels if label != -1}
      outliers = loc_dispositivos2[labels == -1]  # Dispositivos que são outliers

      # ------------------------   Plot dos clusters com o círculo   --------------------------------------------------------

      centroids = k_means.cluster_centers_

      # Calculando o raio dos círculos com base na dispersão dos pontos dentro de cada cluster
      radii = []
      for i in range(n_cluster):
          # Seleciona os pontos do cluster i
          cluster_points = loc_dispositivos2[cluster_labels == i]
          # Calcula o raio como a distância média dos pontos ao centroide
          radius = np.mean(np.sqrt(np.sum((cluster_points - centroids[i])**2, axis=1)))
          radii.append(radius)


      # -------------   Embaralhamento dos dispositivos dentro do seu cluster   -----------------------------------------------------------------

      for label in unique_labels:
          if label != -1:  # Ignorando outliers
              cluster_points = loc_dispositivos2[labels == label]
              np.random.shuffle(cluster_points)  # Embaralhando dispositivos dentro do cluster
              clusters[label] = cluster_points
      outliers = loc_dispositivos2[labels == -1]  # Dispositivos que são outliers


      # --------------    Reodernando os dispositivos com o PB como referência  --------------------


      # Função para calcular a distância entre um ponto e o Power Beacon
      def calcular_distancia_ponto(ponto, PB_position):
          return np.sqrt((ponto[0] - PB_position[0])**2 + (ponto[1] - PB_position[1])**2)

      # Ordenar dispositivos dentro de cada cluster pela distância ao PB
      for cluster_id, dispositivos in clusters.items():
          # Ordena cada cluster pelo dispositivo mais próximo ao PB
          clusters[cluster_id] = sorted(dispositivos, key=lambda dispositivo: calcular_distancia_ponto(dispositivo, PB_position))

      # Ordenar os clusters pela distância do dispositivo mais próximo de cada cluster ao PB
      cluster_ordenado_ids = sorted(clusters.keys(), key=lambda cid: calcular_distancia_ponto(clusters[cid][0], PB_position))

      # Criar lista final de dispositivos ordenados por proximidade ao PB
      dispositivos_ordenados_PB = []
      for cid in cluster_ordenado_ids:
          dispositivos_ordenados_PB.extend(clusters[cid])


      # ---------------------   Canal Power Beacon - Dispositivos  (K,N)   -------------------------------

      h_LoS_PB_D = np.zeros((K,N)).astype(complex)
      h_NLoS_PB_D = np.zeros((K,N)).astype(complex)
      Beta_PB_D = np.zeros(K)
      hH_PB_D = np.zeros((K,N)).astype(complex)
      hH_PB_D_new = np.zeros((K,N)).astype(complex)

          # Construção do canal PB - Dispositivo (kappa_PB_D da ligação pb-disp)
      h_LoS_PB_D = np.random.rand(K,N) + 1j*np.random.rand(K,N) # Matriz (KxN)
      h_NLoS_PB_D = np.random.rand(K,N) + 1j*np.random.rand(K,N) # Matriz (KxN)
      hH_PB_D = (np.sqrt((kappa_PB_D)/(1+kappa_PB_D)) * h_LoS_PB_D) + (np.sqrt((1)/(2*(1+kappa_PB_D))) * h_NLoS_PB_D) # Canal PB-Device


      for k in range(len(dispositivos_ordenados_PB)):
          # Beta PB_D:
          x = dispositivos_ordenados_PB[k][0] #
          y = dispositivos_ordenados_PB[k][1] #            # [a][b] --> a varia de 0-K / b=0=x / b=1=y
          d = np.sqrt(x**2 + y**2)
          Beta_PB_D[k] = (c**2) / ((16*((np.pi)**2)) * (f**2) * (d**alpha))

          hH_PB_D[k, :] = np.sqrt(Beta_PB_D[k])*hH_PB_D[k, :]


      #  -------------   Canal Power Beacon - RIS (N,M)  ----------------------------------------

      h_LoS_PB_RIS = np.zeros((N,M)).astype(complex)
      h_NLoS_PB_RIS = np.zeros((N,M)).astype(complex)
      Beta_PB_RIS = np.zeros(M)
      hH_PB_RIS = np.zeros((N,M)).astype(complex)

          # Construção do canal PB-RIS (1 RIS = um canal do PB até a RIS)
      h_LoS_PB_RIS = np.random.rand(N,M) + 1j*np.random.rand(N,M) # Matriz (NxM)
      h_NLoS_PB_RIS = np.random.rand(N,M) + 1j*np.random.rand(N,M) # Matriz (NxM)
      hH_PB_RIS = (np.sqrt((kappa_PB_RIS)/(1+kappa_PB_RIS)) * h_LoS_PB_RIS) + (np.sqrt((1)/(2*(1+kappa_PB_RIS))) * h_NLoS_PB_RIS) # Canal PB-RIS

      x = RIS_position[0]
      y = RIS_position[1]
      d = np.sqrt(x**2 + y**2)
      Beta_PB_RIS = (((c/f)**2) / ((4*np.pi)**2)) * (d**(-alpha2))
      hH_PB_RIS = np.sqrt(Beta_PB_RIS)*hH_PB_RIS

      # np.shape(hH_PB_RIS)

      # ---------------------   Canal RIS - Dispositivos Tamanho (M, K)   ----------------------------------------

      h_LoS_RIS_D = np.zeros((M,K)).astype(complex)
      h_NLoS_RIS_D = np.zeros((M,K)).astype(complex)
      Beta_RIS_D = np.zeros(K)
      hH_RIS_D = np.zeros((M,K)).astype(complex)
      hH_RIS_D_new = np.zeros((M,K)).astype(complex)

          # Construção do canal RIS-Disp;
      h_LoS_RIS_D = np.random.rand(M,K) + 1j*np.random.rand(M,K) # Matriz (MxK)
      h_NLoS_RIS_D = np.random.rand(M,K) + 1j*np.random.rand(M,K) # Matriz (MxK)
      hH_RIS_D = (np.sqrt((kappa_RIS_D)/(1+kappa_RIS_D)) * h_LoS_RIS_D) + (np.sqrt((1)/(2*(1+kappa_RIS_D))) * h_NLoS_RIS_D) # Canal RIS-D


      for k in range(len(dispositivos_ordenados_PB)):
            # Beta PB_D:
            x = dispositivos_ordenados_PB[k][0] #
            y = dispositivos_ordenados_PB[k][1]  #                  # [a][b] --> a varia de 0-K / b=0=x / b=1=y
            d = np.sqrt((x - RIS_position[0])**2 + (y - RIS_position[1])**2)
            Beta_RIS_D[k] = (c**2) / ((16*((np.pi)**2)) * (f**2) * (d**alpha))

            hH_RIS_D[:, k] = np.sqrt(Beta_RIS_D[k])*hH_RIS_D[:, k]


      #  -----------------------   Canal Completo (N x K)   ----------------------------------------

      H = ((hH_PB_RIS @ theta @ hH_RIS_D) + np.transpose(hH_PB_D))


      # ----------------   CÁLCULO DO TEMPO DE CARREGAMENTO DOS DISPOSITIVOS   -----------------------------------------------------------------------------------------------------

      # Parâmetros Carregamento
      Pr = np.zeros(K)
      Beamform_SCSI = np.zeros((K,N)).astype(complex)
      Gamma = np.zeros(K)
      tempo_carregamento = np.zeros(K)
      Gamma_kj = np.zeros(K)

      # Beamforming S-CSI (h_LoS_PB_D)
      for k in range (0,K):
          Beamform_SCSI[k] = np.transpose(np.sqrt(Pt/N) * (h_LoS_PB_D[k]/np.abs(h_LoS_PB_D[k])))

          #Para PB-Disp e RIS-Disp
      for k in range (0,K):
          Phi_NEIG = np.zeros(K)

          # np.shape(Phi_NEIG)

          # Potência
          Pr[k] = (np.abs(Beamform_SCSI[k].dot(np.transpose(H)[k])))**2

          # Função Logística Tradicional (Gamma):
          Gamma[k] = mu / (1 + (np.exp(-a*(Pr[k] - b))))

          # Tempo de carregamento para o primeiro dispositivo:
          if k==0:
              tempo_carregamento[0] = (E_min * (1-Omega)) / (Gamma[0] - (mu*Omega))
          else:
              for j in range (0, k):
                  # print(j)
                  # Energia total coletada carregando o vizinho (Phi_NEIG):
                  Gamma_kj[j] = mu / (1 + (np.exp(-a*((Beta_PB_D[k]*(np.abs(Beamform_SCSI[j].dot(np.transpose(H)[k]))**2))-b))))
                  Phi_NEIG[j] = tempo_carregamento[j] * ((Gamma_kj[j] - (mu*Omega)) / (1 - Omega))

              if np.sum(Phi_NEIG) > E_min:
                  tempo_carregamento[k] = 0
              else:
                  tempo_carregamento[k] = ((E_min - np.sum(Phi_NEIG))*(1-Omega)) / (Gamma[k] - (mu*Omega))

      tempo_carregamento_total[real,n_disp] = np.sum(tempo_carregamento)
      tempo[cont] = np.mean(np.mean(tempo_carregamento_total))
  cont = cont + 1
  #eixo_x_K = np.append(eixo_x, K)
  eixo_x_N = np.append(eixo_x_N, N)
  #eixo_x_M = np.append(eixo_x, K)





# final do for
print("Terminou de rodar\n")
# %%

print(tempo)

# [147.50063348 261.44753691 405.12657105 562.9755537    0.
#    0.        ]

#%%

# eixo_x = np.delete(eixo_x, 0)
eixo_x_N_2 = np.delete(eixo_x_N, 0)



plt.figure(figsize=(8, 6))
plt.plot(eixo_x_N_2, tempo, marker='o', linestyle='-', color='b', label='Tempo Médio de Carregamento')
plt.title("Relação entre o Número de dispositivos e Tempo Total Médio de carga")
plt.xlabel("Número de Dispositivos")
plt.ylabel("Tempo Total Médio [s]")
plt.grid(True)
plt.legend()
plt.show() 

# np.shape(tempo)
# np.shape(eixo_x_N)


#         # ---------   Localização dos dispositivos entre PB e RIS   ----------------------------------------
# Plotando os pontos no gráfico
plt.figure(figsize=(8, 6))
plt.scatter(x_disp, y_disp, label="Dispositivos", color="blue")
plt.plot(RIS_position[0], RIS_position[1], 'rx', markersize=10, label="RIS")  # RIS em vermelho
plt.plot(PB_position[0], PB_position[1], 'ks', markersize=10, label="Power Beacon (PB)")  # PB em preto
# Configurações de exibição
plt.xlabel('X Coordenada')
plt.ylabel('Y Coordenada')
plt.legend(loc='upper left')
plt.title('Localização dos dispositivos entre PB e RIS')
plt.grid(True)
plt.show()


  #  ------------------   ELBOW METHOD PARA O N° DE CLUSTERS   -----------------------------------

# Mostra o Gráfico
plt.plot(range(1, K), wcss)
plt.title('Curva de Cotovelo')
plt.xlabel('Numero de Clusters')
plt.ylabel('WCSS') #within cluster sum of squares
plt.show()

print(f'\nMelhor número de clusters: {melhor_n_clusters} com coeficiente de silhueta de {melhor_score}')



# -------------   Plotando os dispositivos Clusterizados e o Power Beacon + RIS   ------------------------------------------
plt.figure(figsize=(8, 6))
plt.scatter(loc_dispositivos2[:, 0], loc_dispositivos2[:, 1], c=cluster_labels, cmap='viridis', label="Dispositivos")
plt.scatter(PB_position[0], PB_position[1], color='red', marker='x', s=100, label="Power Beacon (PB)")
plt.scatter(RIS_position[0], RIS_position[1], color='blue', marker='x', s=100, label="RIS")
plt.xlabel('X Coordenada')
plt.ylabel('Y Coordenada')
plt.legend()
plt.title('Clusterização dos Dispositivos')
plt.show()


# ----------------------   Plot dos clusters com o círculo   --------------------------------------------------------
centroids = k_means.cluster_centers_
# Calculando o raio dos círculos com base na dispersão dos pontos dentro de cada cluster
radii = []
for i in range(n_cluster):
    # Seleciona os pontos do cluster i
    cluster_points = loc_dispositivos2[cluster_labels == i]
    # Calcula o raio como a distância média dos pontos ao centroide
    radius = np.mean(np.sqrt(np.sum((cluster_points - centroids[i])**2, axis=1)))
    radii.append(radius)
# Plotando os dispositivos, o Power Beacon e os clusters com círculos
plt.figure(figsize=(8, 6))
plt.scatter(loc_dispositivos2[:, 0], loc_dispositivos2[:, 1], c=cluster_labels, cmap='viridis', label="Dispositivos")
plt.scatter(PB_position[0], PB_position[1], color='red', marker='x', s=100, label="Power Beacon (PB)")
plt.scatter(RIS_position[0], RIS_position[1], color='blue', marker='x', s=100, label="RIS")
# Desenhando círculos ao redor de cada cluster
for i, centroid in enumerate(centroids):
    circle = plt.Circle(centroid, radii[i], color='gray', fill=False, linestyle='--', linewidth=1.5)
    plt.gca().add_patch(circle)
# Configurações do gráfico
plt.xlabel('X Coordenada')
plt.ylabel('Y Coordenada')
plt.legend()
plt.title('Marcação dos clusters')
plt.axis('equal')
plt.show()


